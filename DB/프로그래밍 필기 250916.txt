F보다 큰 이름 = F다음 알파벳이 앞글자인 이름(여러글자 비교해도 가능

선입견을 가지면 버그가 생길수도 있음 <> 도 부정이긴 하지만 보통 !=로 씀 ( ^= 도 부정임)
WHERE NOT ~~ = ~~; 도 부정임
WHERE NOT ~~ != ~~;은 이중부정이라 긍정

WHERE ~~ IN ( ~~, @@, ##)하면 OR붙인거랑 같은 효과
AND 부정문 붙일수도 있지만
WHERE ~~ NOT IN ( @@,##,$$) 를 많이 씀(@@ ## $$가 아닌 사람)

WHERE @@ >= 2000
AND @@ <= 3000; 이건 @@가 2000이상 3000이하
WHERE @@ BETWEEN 2000 AND 3000;도 같은효과(이것도 이상, 이하임. 그래서 <      > 로는 못씀, 3000 AND 2000으로 하면 안되더라)

WHERE @@ NOT BETWEEN 2000 AND 3000; 		<-	2000~이상3000이하가 아닌것

WHERE @@ LIKE 'S%';		<-	S와 같은(S로 시작하는)이름 표시(연관검색어 만들기 좋음)	0개이상의 글자를 요구하는 와일드카드
WHERE @@ LIKE '_L%';		<-	앞에 글자가 하나있고 두번째글짜가 L인거, 			정확히 1개의 글자를 요구함
WHERE @@ LIKE '%AM%';	<-	양옆에 글자가 있어도 되고 없어도 되는 AM 포함글자
NOT LIKE				<-	지정한 글자가 들어있지 않은

하지만 LIKE에서 %는 와일드카드이고 성능저하를 유발하니 주의해야한다
NULL값을 자바에 넣으면 터지므로 디폴트값으로 바꿔줘야한다.

WHERE ## IS NULL;로 ##가 NULL인 데이터를 찾는다
WHERE ## IN NOT NULL; ##가 NULL이 아닌 데이터를 찾는다

NULL은 비교할 수 없고 IS NULL,	IS NOT NULL로만 찾을수 있다

UNION		<-		OR과 비슷한 기능. SELECT부터 다시 해야한다.(UNION JOIN기능이라고도 함)

ex)
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 20;

DEPTNO가 10인 집합과 20인집합을 합침
하지만 SELECT의 컬럼 개수가 같아야 한다.☆☆☆☆☆
또한 데이터타입이 같아야함
컬럼종류가 달라도 타입만 맞으면 ㄱㅊ(그래도 내용이 섞이니까 안하는게 좋을것)

UNION은 중복을 제거하고
UNION ALL은 전부 보여준다	ex) 같은 쿼리문을 유니온으로 붙이면 변함이 없지만 UNION ALL로 하면 똑같은게 붙는다.

UNION, UNION ALL을 집합연산자(집합쿼리)라고 부른다

MINUS는 차집합이다. 큰 집합에서 밑의 집합과 곂치는걸 뺀다.
INTERSECT는 교집합이다. 큰 집합과 밑의 집합의 곂치는것만 표시한다.		<- 이건 잘 안씀. JOIN(교집합)을 쓰는게 더 많아서

만약 컬럼명을 카피하고싶으면 테이블에서 들어가서 열면 됨


6장 오라클 함수

내장함수(내장그래픽같은거임)
함수와 프로시즈 폴더는 내가 만들어서 쓰는 함수, 프로그램임

UPPER	모든 문자를 대문자로 변환
LOWER	모든 문자를 소문자로 변환
INITCAP	첫글자만 대문자, 나머지는 소문자로 변환

6-2 함수를 써서 비교

WHERE LOWER(ENAME) = LOWER('KING');도 가능

SELECT다음에도 함수넣을수 있지만
FROM다음에는 안넣는다

6-3 

FROM DUAL : 테스트할때 쓰는거
WHERE UPPER(ENAME) LIKE UPPER('%king%'); - king은 KING으로 나옴

SELECT UPPER('%king%')
FROM DUAL;하면 %KING%라고 나옴

SQL은 지긋이 바라보고 해야함

LENGTH를 알고 짜야댄다.
LENGTH는 글자의 수를 감지.
SELECT ENAME, LENGTH(ENAME)
FROM EMP; 하면 이름의 숫자를 띄워줌, 이걸 비교할수도 잇음 EX) LENGTH가 4보다 큰사람

LENGTHB('@@') - 글자의 바이트 감지

NVACHAR2에서 이모지도 저장할 수 있다😎

SUBSTR은 큰 코드에서 원하는코드 추출할 때 사용 SUBSTR(문자열, 시작위치 [, 길이]) 
		시작위치 1부터,숫자가 음수면 뒤에서, 시작위치가 0이면 1로 처리된다
SUBSTR(JOB, 1, 2)	<-	JOB에서 1번째, 2번째 글자 빼고 잘라냄
SUBSTR(JOB, 3, 2)	<-	JOB에서 3번째, 2번째 글자 빼고 잘라냄
SUBSTR(JOB, 6)		<-	JOB에서 6번째 이상부터 표시(5개 이하면 NULL)
SUBSTR(JOB, -3, 2)	<-	JOB에서 뒤에서 3번째부터, 길이 2

https://buly.kr/AwfxE7z 오라클 페이지

INSTR('HELLO, ORACLE!', 'L') AS INSTR_1		<- 문장에서 L이 처음 보이는곳의 위치(3) 
INSTR('HELLO, ORACLE!','L', 5) AS INSTR_2	<-	문장에서 5번째 이후에 L이 처음 보이는 위치(12)
INSTR('HELLO, ORACLE!', 'L',2,2) AS INSTR_3	<-	문장에서 2번째 이후에 L이 두번째로 보이는 위치(4)
많이 쓰는 함수임

퀴즈)
1.INSTR + SUBSTR: 결과가 in이 나오도록 짜보세용
occurrence is an integer indicating which occurrence of substring in string Oracle should search for.
INSTR(C1, 'i', 1, 8)	여기서 숫자가 나옴(67?)
SELECT SUBSTR(C1,INSTR(c1,'i',1,8), 2)
FROM TEST;	하면 in이 나옴

커밋 : 진짜 그렇게 하겠다.
롤백 : 취소하겠다.
도구 - 환경설정 - 객체뷰어에서 자동커밋설정 해버리면 위험함(마구 반영되어버림)※

가급적 인덱스 찾는건 조심하자(성능많이먹음)

퀴즈2)
사원명에 S가 들어잇지 않다면 INSTR은 무슨값을 리턴하나요?
SELECT ENAME, INSTR(ENAME, 'S')		이름을 나열하고 S가 있는 위치를 알림
FROM EMP			로 확인해보니 0을 리턴함

ORACLE은 * 뒤에 쉼표를 해석못함 ( EMP.*은 EMP밑에 모든거라 괜찮음)

6-11

LIKE는 패턴매칭에 씀 LIKE 'ABC%'일때만 사용가능하는게 좋음, 그외엔 느림
INSTR은 인덱스사용불가, 언제나 전체스캔(대량데이터에서 느림), 단순히 포함여부 확인에 좋음
대규모 텍스트 검색에선 ELASTICSEARCH(엘라스틱서치)쓰는게 좋음

REPLACE <- 제거하거나 대체시킬때 씀

SELECT 'Oracle',
       LPAD('Oracle', 10, '#') AS LPAD_1,		<-	ORACLE앞에 #을 10글자가 될때까지 채우고 LPAD_1라고 이름지음
       RPAD('Oracle', 10, '*') AS RPAD_1,		<-	ORACLE뒤에 *을 10글자가 될때까지 채우고 RPAD_1라고 이름지음
       LPAD('Oracle', 10) AS LPAD_2,			<-	ORACLE앞에 공백을 10글자가 될때까지 채우고 LPAD_2라고 이름지음
       RPAD('Oracle', 10) AS RPAD_2			<-	ORACLE뒤에 공백을 10글자가 될때까지 채우고 RPAD_2라고 이름지음
  FROM DUAL;					

CSS PADDING 배워보셈
디자인에 좋음?	BOOTSTRAP도

CONCAT(%%%,$$$)		<-	%%%와 $$$를 연결시킨다.
CONCAT(%%%, CONCAT(' : ', $$$))	<-	%%% : $$$로 표현가능
||	<-	문자와 문자를 이어줌(\에 SHF한거)
TRIM은 쓸모없는걸 잘라낸다
SELECT '[' || TRIM(' _ _Oracle_ _ ') || ']' AS TRIM		결과물->	[_ _Oracle_ _]	||영어로 파이프파이프라고함

 '[' || LTRIM('<_Oracle_>', '_<') || ']' AS LTRIM_2		<-	왼쪽꺽쇠만 지우겟다

SELECT ROUND(1234.5678) AS ROUND,				1235
       ROUND(1234.5678, 0) AS ROUND_0,			1235
       ROUND(1234.5678, 1) AS ROUND_1,			1234.6
       ROUND(1234.5678, 2) AS ROUND_2,			소수점 두자리까지 보여주고 반올림(1234.57)
       ROUND(1234.5678, -1) AS ROUND_MINUS1,		1230
       ROUND(1234.5678, -2) AS ROUND_MINUS2		1200
  FROM DUAL;

SELECT TRUNC(1234.5678) AS TRUNC,				TRUNC는 짤라버리는거 1234
       TRUNC(1234.5678, 0) AS TRUNC_0,				1234
       TRUNC(1234.5678, 1) AS TRUNC_1,				1234.5
       TRUNC(1234.5678, 2) AS TRUNC_2,				1234.56
       TRUNC(1234.5678, -1) AS TRUNC_MINUS1,		1230
       TRUNC(1234.5678, -2) AS TRUNC_MINUS2		1200
  FROM DUAL;

SELECT CEIL(3.14),							CEIL은 올림(4)
       FLOOR(3.14),							FLOOR은 내림(3)
       CEIL(-3.14),								-3
       FLOOR(-3.14)							-4
  FROM DUAL;								

SELECT MOD(15, 6),							MOD는 나머지, 15를 6으로 나눈 나머지(3)
       MOD(10, 2),								0
       MOD(11, 2)								1
  FROM DUAL;