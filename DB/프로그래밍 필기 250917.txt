SYSDATE	<-	오늘(시간분초도 잇긴함)
SYSDATE-1	<-	어제
SYSDATE+1<-	내일

SELECT SYSDATE,				결과
ADD_MONTHS(SYSDATE, 3)		25/09/17		25/12/17						
FROM DUAL;				현재날짜에 +3개월

SELECT EMPNO, ENAME, HIREDATE, SYSDATE,						고용일과 현재일의 차이
       MONTHS_BETWEEN(HIREDATE, SYSDATE) AS MONTHS1,			과거가 뒤에 와야 음수가 안나옴
       MONTHS_BETWEEN(SYSDATE, HIREDATE) AS MONTHS2,			TRUNC는 자르는것(숫자나 날짜의 소수점)
       TRUNC(MONTHS_BETWEEN(SYSDATE, HIREDATE)) AS MONTHS3
FROM EMP;

오라클에서 DAY가 나오면 어떤요일임

SELECT SYSDATE,
NEXT_DAY(SYSDATE, '월요일'),		다음의 월요일은 무슨날? -> 25/09/17	->	25/09/22
LAST_DAY(SYSDATE)				마지막 월요일은 무슨날? -> 25/09/30
FROM DUAL;

요일 지정에서 일월화수목금토(1234567)로 지정할 수 있음 EX) NEXT_DAY(SYSDATE, 1) 하면 다음 일요일 알려줌

DB에서 많이 쓰는거
1)ORACLE	우리가 쓰고잇는거(자바와 결탁)
2)MS SQL 	보통 앞에 MS 생략(우리꺼아님, ASP, #, .net등, 보안좋음)
3)MySQL(MariaDB)	-	단순
4)Postgre = 저렴하고 일본에서 많이 씀

유료프로그램 쓰는이유? 고장나면 회사에 청구가능

WAS서버
1) IBM이 만든 WEBSPERE, WEBLOGIC(검증되고 성능좋아서 많이 씀)
2) TMAX가 만든 JBOSS		
3) TOMCAT: 무료

SELECT SYSDATE,							ROUND는 반올림
       ROUND(SYSDATE, 'CC') AS FORMAT_CC,		CC는 네자리연도의 끝두자리 기준 반올림
       ROUND(SYSDATE, 'YYYY') AS FORMAT_YYYY,	YYYY는 연도에서 7월1일기준 반올림 - 26/01/01
       ROUND(SYSDATE, 'Q') AS FORMAT_Q,		Q는 쿼터, 4분기로 나눠 반올림 - 25/10/01
       ROUND(SYSDATE, 'DDD') AS FORMAT_DDD,	DDD는 정오기준 반올림 - 25/09/17(실제는 17일10시35분)
       ROUND(SYSDATE, 'HH') AS FORMAT_HH		HH는 시간기준 반올림 - 25/09/17[11시] (실제는 17일 10시 35분)
  FROM DUAL;
ROUND 대신 TRUNC쓰면 그냥 내림

SELECT EMPNO, ENAME, EMPNO || '500'		결과	7839		KING	->	7839500
  FROM EMP						만약 ||대신 +쓰면 붙이는게 아니라 계산이 되어서 더해버림 7839+500=8339
 WHERE ENAME = 'KING';

SELECT 'ABCD' + EMPNO, EMPNO			결과	오류남 -> 더하기는 숫자만 지원한다. -> +를||로 바꾸면 붙일수 잇음
  FROM EMP
 WHERE ENAME = 'KING';
데이터베이스 배열에서 뭔가를 집어넣어서 배열이 늘어나면 데이터가 클수록 엄청 느림. 컬럼추가도 안됨
그래서 꼼수로 두가지데이터를 한곳에 넣고 쓸때 SUBSTR로 쪼개서 두 데이터로 만들어서 씀

SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD HH24:MI:SS') AS 현재날짜시간		여기서 개조해서 쓸수잇음
  FROM DUAL;											YY까지만쓰면 25만 띄우고 SS를 땔수도 잇고 /를 .으로 바꿔도 댐

SELECT SYSDATE,									결과
       TO_CHAR(SYSDATE, 'MM') AS MM,					25/09/17	09	9월 	9월 	17	수	수요일
       TO_CHAR(SYSDATE, 'MON') AS MON,
       TO_CHAR(SYSDATE, 'MONTH') AS MONTH,
       TO_CHAR(SYSDATE, 'DD') AS DD,
       TO_CHAR(SYSDATE, 'DY') AS DY,
       TO_CHAR(SYSDATE, 'DAY') AS DAY
  FROM DUAL;

SELECT SYSDATE,										결과 25/09/17	09	9월 	9月 	SEP	9월 	9月 	SEPTEMBER
       TO_CHAR(SYSDATE, 'MM') AS MM,									NLS란? NATIONAL LANGUAGE SUPPORT
       TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE = KOREAN' ) AS MON_KOR,
       TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE = JAPANESE') AS MON_JPN,
       TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE = ENGLISH' ) AS MON_ENG,
       TO_CHAR(SYSDATE, 'MONTH', 'NLS_DATE_LANGUAGE = KOREAN' ) AS MONTH_KOR,
       TO_CHAR(SYSDATE, 'MONTH', 'NLS_DATE_LANGUAGE = JAPANESE') AS MONTH_JPN,
       TO_CHAR(SYSDATE, 'MONTH', 'NLS_DATE_LANGUAGE = ENGLISH' ) AS MONTH_ENG
  FROM DUAL;

SELECT SYSDATE,							결과 25/09/17	09	17	수	水	WED	수요일	水曜日	WEDNESDAY
       TO_CHAR(SYSDATE, 'MM') AS MM,
       TO_CHAR(SYSDATE, 'DD') AS DD,
       TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE = KOREAN' ) AS DY_KOR,
       TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE = JAPANESE') AS DY_JPN,
       TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE = ENGLISH' ) AS DY_ENG,
       TO_CHAR(SYSDATE, 'DAY', 'NLS_DATE_LANGUAGE = KOREAN' ) AS DAY_KOR,
       TO_CHAR(SYSDATE, 'DAY', 'NLS_DATE_LANGUAGE = JAPANESE') AS DAY_JPN,
       TO_CHAR(SYSDATE, 'DAY', 'NLS_DATE_LANGUAGE = ENGLISH' ) AS DAY_ENG
  FROM DUAL;

SELECT SYSDATE,
       TO_CHAR(SYSDATE, 'HH24:MI:SS') AS HH24MISS,		HH24는 24시간제(이게가장좋음)
       TO_CHAR(SYSDATE, 'HH12:MI:SS AM') AS HHMISS_AM,	HH12는 12시간제(오전오후도 붙여야함)
       TO_CHAR(SYSDATE, 'HH:MI:SS P.M.') AS HHMISS_PM
  FROM DUAL;

SELECT SAL,				결과 800	     $800	            ￦800	     800.00	 000,000,800.00	 000000800.00	       8,00
       TO_CHAR(SAL, '$999,999') AS SAL_$,			$로, 3자리마다 콤ㅁ
       TO_CHAR(SAL, 'L999,999') AS SAL_L,			L은 로컬(자동으로 나라별 화폐로 바뀜)
       TO_CHAR(SAL, '999,999.00') AS SAL_1,
       TO_CHAR(SAL, '000,999,999.00') AS SAL_2,
       TO_CHAR(SAL, '000999999.99') AS SAL_3,
       TO_CHAR(SAL, '999,999,00') AS SAL_4
  FROM EMP;

SELECT 1300 - '1500',		결과 -200	2800	<-계산 해준다는것(콤마까진 계산안함)
      '1300' + 1500
 FROM DUAL;

SELECT TO_NUMBER('1,300', '999,999') - TO_NUMBER('1,500', '999,999')		이렇게 1.300도 1300으로 인식가능
  FROM DUAL;

SELECT TO_DATE('2018-07-14', 'YYYY-MM-DD') AS TODATE1,		결과 18/07/14	18/07/14
       TO_DATE('2018/07/14', 'YYYY/MM/DD') AS TODATE2
  FROM DUAL;										문자를 날짜데이터로 바꿀 수 있다.
만약 미국식 형식인 M/D/Y로 바꾸려면 MM/DD//YYYY로 하면 될거다
영국식은 D/M/Y임ㅋ

SELECT *				날짜는 좀더 최근(미래)가 더 크다
  FROM EMP
 WHERE HIREDATE > TO_DATE('1981/06/01', 'YYYY/MM/DD');		정해진 날짜보다 큰사람 (나중에 입사한 사람) 명단 보여줘 라는뜻

SELECT TO_CHAR(TO_DATE('49/12/10', 'YY/MM/DD'), 'YYYY-MM-DD') AS YY_YEAR_49,
       TO_CHAR(TO_DATE('49/12/10', 'RR/MM/DD'), 'YYYY-MM-DD') AS RR_YEAR_49,
       TO_CHAR(TO_DATE('50/12/10', 'YY/MM/DD'), 'YYYY-MM-DD') AS YY_YEAR_50,
       TO_CHAR(TO_DATE('50/12/10', 'RR/MM/DD'), 'YYYY-MM-DD') AS RR_YEAR_50,
       TO_CHAR(TO_DATE('51/12/10', 'YY/MM/DD'), 'YYYY-MM-DD') AS YY_YEAR_51,
       TO_CHAR(TO_DATE('51/12/10', 'RR/MM/DD'), 'YYYY-MM-DD') AS RR_YEAR_51
  FROM DUAL;
결과 2049-12-10	2049-12-10	2050-12-10	1950-12-10	2051-12-10	1951-12-10
일단 49/12/10이라는 문자를 날짜로 바꾸고, 날짜를 원하는 형식의 문자로 다시 바꿔서 출력


SELECT EMPNO, ENAME, SAL, COMM, SAL+COMM,
       NVL(COMM, 0),
       SAL+NVL(COMM, 0)
  FROM EMP;
결과 7369	SMITH	800	NULL	NULL	0	800
NVL이란? NULL값을 지정한 디폴트값으로 변환 EX)NVL(COMM, 0)면 COMM이 NULL이면 0으로 한다는뜻		☆※★
변환하는 이유? NULL이 잇으면 터질수도 잇고, 계산을 할수 잇게 만들어야 하기때문. 왠만하면 무조건 넣으셈


SELECT EMPNO, ENAME, COMM,
       NVL2(COMM, 'O', 'X'),
       NVL2(COMM, SAL*12+COMM, SAL*12) AS ANNSAL
  FROM EMP;
결과
7369	SMITH		X	9600
7499	ALLEN	300	O	19500
NVL2(엔비엘つ)란? 자바로치면 IF문사망연산자(?)	NULL이 아닌경우 첫번째로 변환, NULL인경우 두번째로 변환(설계서쓸때 많이씀)


SELECT EMPNO, ENAME, JOB, SAL,
       DECODE(JOB,
              'MANAGER' , SAL*1.1,	<-매니저는 10퍼 보너스!
              'SALESMAN', SAL*1.05,	<-세일즈맨은 5퍼!
              'ANALYST' , SAL,		<-넌 없어
              SAL*1.03) AS UPSAL	<-나머지는 3퍼!
  FROM EMP;
결과 7369	SMITH	CLERK	800	824
DECODE란? Oracle의 DECODE 함수는 SQL 내에서 조건에 따른 값 반환(if–else 로직)을 간단하게 구현할 수 있는 내장 함수입니다.
NVL다음으로 인기많은 함수임
DECODE(비교식,
       비교값1, 반환값1,
       비교값2, 반환값2,
       …,
       기본값)


SELECT EMPNO, ENAME, JOB, SAL,
       CASE JOB
          WHEN 'MANAGER' THEN SAL*1.1
          WHEN 'SALESMAN' THEN SAL*1.05
          WHEN 'ANALYST' THEN SAL
          ELSE SAL*1.03
       END AS UPSAL
  FROM EMP;
CASE는 DECODE와 같은거임. 형식이 좀 다르긴 함 결과는 위의 DECODE와 같음

오라클 SQL 주석달기
-- 하고 달면 됨. 일본에선 개발할때 설계서가 필요하고 설계서변경변호(셋펜방고) 필요
	

SELECT EMPNO, ENAME, COMM,
       CASE
          WHEN COMM IS NULL THEN '해당사항 없음'		<-	뽀나스 정보가 없으요
          WHEN COMM = 0 THEN '수당없음'			<-	뽀나스가 없으요
          WHEN COMM > 0 THEN '수당 : ' || COMM		<-	뽀나스에용
       END AS COMM_TEXT
  FROM EMP;
CASE를 비교로도 사용할 수 있다.


7장 다중행 함수

하나의 행으로 여러 결과를 출력한다

SELECT SUM(SAL)	-> 사원의 연봉합계를 보여줘
  FROM EMP;
결과 24925

원래 SELECTION하면 한 열(가로)로 뽑는데
프로젝션으로 뽑으면 한 행(세로)로 뽑는다

그룹->압축(AGREGOTE?)

SELECT ENAME, SUM(SAL)
  FROM EMP;
결과 : 에러		단일그룹의 그룹함수가 아닙니다
에러가 나는 이유? -> SUM은 그룹함수인데 이것은 SAL값을 그룹으로 하나로 만들어버린거임
근데 ENAME은 그룹함수가 아님??

☆ 오늘의 하이라이트 ☆(GROUP BY)

이걸 해결하려면
SELECT AVG(SAL), DEPTNO
  FROM EMP
GROUP BY DEPTNO; 쓰면 됨
GROUP BY 는 DEPTNO에 ~별 을 붙인다 생각하셈. 부서별~ 직급별~얼마~ 이런거
AVG로 SAL의 평균을 내고, 압축이 안된 DEPTNO를 GROUP BY로 그룹인척 함
시험문제 단골(GROUP BY 가려놓고 옳은 글자 고르기)

그래서
SELECT ENAME, SUM(SAL)
FROM EMP;
이걸 고치면
SELECT ENAME, SUM(SAL)
FROM EMP
GROUP BY ENAME;
가 되고 결과는
SMITH	800
ALLEN	1600
WARD	1250
JONES	2975
MARTIN	1250
BLAKE	2850
CLARK	2450
KING		5000
TURNER	1500
JAMES	950
FORD		3000
MILLER	1300


SELECT SUM(DISTINCT SAL),
       SUM(ALL SAL),
       SUM(SAL)
       FROM EMP;
결과 23675	24925	24925


SELECT COUNT(*)
FROM EMP
WHERE DEPTNO = 30;
EMP의 DEPTNO가 30인 사람을 센다.
결과 6
이것을 베이직 함수라고 부른다

전체건수의 수를 알고, 원하는것만 SELECT로 불러와야함. 

PSEDO(가짜라는 의미의 '수도')

모르는 테이블은 받았는데 FULL SELECT하면 큰일
우선 DESCRIBE하고
DESC는 ORDER BY 절의 DESC (내림차순)와 DESCRIBE 명령의 축약형 (테이블 구조 조회)이 있음
===============
DESC EMP;

SELECT COUNT(*)
FROM EMP;						이 3개 중요!

SELECT ROWNUM, EMP.*
FROM EMP
WHERE ROWNUM < 3;
===============
결과
1	7369	SMITH	CLERK	7902	80/12/17	800		20
2	7499	ALLEN	SALESMAN	7698	81/02/20	1600	300	30

근데 ROWNUM도 성능이슈가 있다
내림/오름차순 정렬을 미리 해놓지 않으면 잘못될 수 있음

애초에 ROWNUM이 뭐냐?
ROWNUM은 ROW_NUMBER() 같은 윈도우 함수가 아니며, 쿼리 수행 과정에서 “가져온 순서”대로 번호를 매깁니다.
순번 부여는 WHERE 절 처리 이전에 이루어지기 때문에,
WHERE ROWNUM < 5 처럼 작은 수 필터링은 원하는 대로 작동
WHERE ROWNUM > 5 처럼 큰 수 필터링은 항상 빈 결과를 반환합니다.

ROWNUM > N 조건 사용법 (서브쿼리 활용)
ROWNUM > N 형태로 “일반적인” 페이지 넘김을 구현하려면, 
먼저 내부 서브쿼리에서 ROWNUM을 매기고 외부에서 조건을 거는 방식을 사용해야 합니다.


SELECT COUNT(*)
FROM EMP;
에선 12가 나오는데
SELECT COUNT(COMM)
FROM EMP;
에선 4가 나온다면
12 - 4 = 8개가 카운팅이 되지 않는 NULL값이라는 뜻이다.
그러니 NVL, NVL2를 사용해서 NULL값을 디폴트로 바꿔주어야 시스템에 EXCEPTION(에러)가 없을것

SELECT COUNT(COMM)
FROM EMP
WHERE COMM IS NOT NULL;
해석: COMM중에 NULL값이 아닌 EMP의 숫자 = 4


SELECT MAX(SAL)
FROM EMP
WHERE DEPTNO = 10;
해석: EMP에서 DEPTNO가 10인 사람의 SAL MAX값(최대연봉)을 뽑아줘 -> 5000

SELECT MIN(SAL)
FROM EMP
WHERE DEPTNO = 10;
해석: EMP에서 DEPTNO가 10인 사람의 SAM MIN값(최소연봉)을 뽑아줘 -> 1300

SELECT MAX(HIREDATE)
  FROM EMP
 WHERE DEPTNO = 20;
20번에 가장 오래된사람

SELECT AVG(SAL)
  FROM EMP
 WHERE DEPTNO = 30;
해석: 30번의 평균연봉

SELECT AVG(SAL), '10' AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL), '20' AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL), '30' AS DEPTNO FROM EMP WHERE DEPTNO = 30;
무식한 코드

SELECT AVG(SAL), DEPTNO
  FROM EMP
GROUP BY DEPTNO;
스마트한 코드 : 부서별 평균연봉

SELECT DEPTNO, JOB, AVG(SAL)
  FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;
해석: EMP의 부서번호, 직업, 평균연봉순으로 그룹화해서 정렬
정렬은 가급적 마지막에 하기, GROUP BY에 그룹이 두개니까 SELECT도 두개 필요함
ORDER BY의 디폴트는 오름차순(1234ABCD)

GROUP BY 중요하니까 까먹지마 ! ! !
이거에 조건을 달고싶으면 HAVING AVG(	) 비교문 


SELECT ENAME, DEPTNO, AVG(SAL)
FROM EMP
GROUP BY DEPTNO;
이건 에러


SELECT DEPTNO, JOB, AVG(SAL)
  FROM EMP
  WHERE SAL <= 3000
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;
해석: 연봉이 3000 이하인 사람중에서 연봉이 2000이상인 사람을 부서번호 직업순 정렬(오름차)
결과
10	MANAGER	2450
20	ANALYST	3000
20	MANAGER	2975
30	MANAGER	2850