체크리스트 
1. 나는 자료형을 이해하고 있다.			X
2. 나는 변수를 이해하고 있다.				O
3. 나는 메소드를 이해하고 있다.			O
4. 나는 클래스를 이해하고 있다.			O
5. 나는 오버로딩을 이해하고 있다.			X
6. 나는 new를 이해하고 있다.				X
7. 나는 static을 이해하고 있다.			O
8. 나는 if문을 이해하고 있다.				O
9. 나는 for문을 이해하고 있다.			O
10. 나는 배열을 이해하고 있다.			X

1. 나는 구구단을 짤 수 있다.				O
2. 나는 메소드를 설계하고 사용 할 수 있다.	O
3. 나는 클래스를 설계하고 사용 할 수 있다.	O
4. 나는 배열을 생성하고 사용 할 수 있다.		X
5. 나는 기본 프로그램을 짤 수 있다.			X


자료형

기본형과 참조형이 있음
기본형은 값 자체를 저장한다 (int double char boolean)
참조형은 객체의 주소를 저장한다(화살표) - > 즉 new, 인스턴스를 생성한다 ( String, 배열, 클래스, 인터페이스 등)


변수

전역(global)변수와 지역(local)변수
전역변수는 클래스 내에서 쓰이고 인스턴스(new)와 클래스변수인 스태틱이 있다.
지역변수는 메소드 내에서 쓰이고 메소드 내에서 선언된 변수와 매개변수가 있다.

누구도 참조하지 않는 new 인스턴스는 가비지(쓰레기)라고 부르며 사라진다.
스태틱은 클래스가 종료될때 사라진다.

지역변수는 메소드가 종료되면 사라진다.


메소드

메소드는 처리, 기능, 액션이다.
RT 		MN 		(parameter) 		{ code ]
리턴		메소드	매개변수			if문 for문등등
타입		네임

RT에 리턴이 없으면 void 잇으면 int,String
메소드네임은 동사+명사로 지음


클래스

구성요소 3가지 : 변수(정보), 생성자, 메소드(처리)

클래스에 선언된 변수를 전역변수
메소드에 선언된 변수를 지역변수라 부름
생성자는 new(생성될때)할때 생성
object를 객체라고 한다.(메모리에 올라가야 사용됨)
메모리에 올라간 객체를 인스턴스라고 함.

변수: 		타입 변수명 = 값;

생성자:	클래스명(매개변수) { 코드 }

메소드:	리턴타입 메소드명 (매개변수) { 코드 }


오버로딩(과적)

생성자 오버로딩과 메소드 오버로딩이 있다.
생성자 오버로딩: 생성자가 동일한 메소드가 존재할 수 있다. -> 매개변수가 다르다.
메소드 오버로딩도 메소드명은 같지만 매개변수가 다르다. 매개변수의 개수나 타입(자료형)이 다르면 정의가 가능하다.

즉 메소드명이나 생성자명이 같고 매개변수의 개수나 타입이 다른걸 여러개 만들면 오버로딩이다.(매개변수 순서가 바뀌는것도 가능)
오버로딩하는 이유? 사용자 입장에서 편하게 여러 상황에 쓸 수 있게 하는 배려

생성자가 다른 생성자를 부를 수 있게 하는게 this다


new - 객체를 생성하는 키워드

클래스를 설계하고 메모리에 올리면 객체가 생성되었다고 한다(인스턴스가 생성).

자바 가상 머신(JVM)은 메소드영역M/스택영역S/힙영역H 으로 나뉘어있고 				(MSH)
정보(변수)는 힙영역에 올라간다. 
메소드(처리)는 당연히 메소드 영역에 올라간다.
스택은 메인메소드와 지역변수등이 쌓이는 영역이다.
jdk(개발자도구) jre(자바구동환경)

new 		클래스명 		( 매개변수 )
객체		생성			생성

참조	=	new	클래스명	(매변)
String은 클래스지만 너무 자주쓰는거라 new없이도 쓸 수 있게 해놓음(배열도 마찬가지)
new
new
new 이런싯으로 하면 각각 인스턴스(변수)에 올라간 주소가 다르다. 메소드는 하나만 만들어지고 참조함
그래서 보통은 new 한번만 쓰면 되고
java bean클래스에서 new 여러번 씀


static

static은 생성할 필요가 없다 = 이미 메모리에 올라가 있음 -> new 쓸 필요가 없다

그래서 클래스를 로딩하는 역할을 맡음(클래스 로더)
클래스가 로딩 될때 JVM이 먼저 메모리에 올려놓음

변수에 붙일 경우 미리 올라가 공유되는 정보가 된다.
메소드의 경우 공유되는 처리가 된다.
이 두가지를 공통팀(common team)이라고 한다. -> 코드 좀 치는사람이 만들어 놓는 경우가 많음 -> 더 잘하면 아키텍쳐팀으로 올라감(몸값상승)

호출하는법 - 클래스명.변수명			클래스명.메소드명

상수 만들때도 씀 public static final ~~~;


if, for문

if( ) { }	괄호 안은 비교조건식(true or false) - 비교조건식( 작거나 크거나 같다, 다르다 ) 중괄호에 코드넣음
if에 해당하지 않는 else if(if를 제외한 나머지중에 이런조건), else문(나머지 다) 사용 가능
for( ) { } 괄호 안은 (초기 식; 조건식; 증가식)을 넣음. ex)  (int i = 0; i < 100; i++)
흐름은 초기 - > 조건 -> 코드실행 -> 증가 -> 조건 -> 코드실행 -> 증가 . . . 조건이 false가 될때까지

break; continue; while(조건식) 도 쓸수 잇다
for문 중첩도 가능하다


배열

여러가지 [	] 배열을 표시한다.
referance 타입이다.
배열은 동일한 자료형만 가능 ex) int면 int만 여러개, char면 char만 여러개
여러개의 데이터를 하나의 참조변수로 사용하고 싶을때 사용
[0] [1] [2] [3] [4] ... [n] 이런 순서를 인덱스라고 한다.
또한 인덱스가 여러개가 있으니 for문을 써야함
배열의 크기는 변경이 안된다 -> immutable(불변)
그래서 이걸 변경시도하면 변경되는게 아니라 복사를 해서 새로 만든다

복사에는 얕은 복사와 깊은 복사가 있다.

얕은복사는 껍데기만 다르고 같은곳을 참조
깊은복사는 새로 참조하는곳을 만들어서 완전히 분리된다



클래스 설계 실기)
1. 손님이 스벅에 가서 돈을 주고 커피를 산다.
2. 카톡 단톡방을 통해서 우리는 메세지를 주고받는다.


