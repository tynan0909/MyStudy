List가 막 넣어도 되는 이유? 오브젝트라서 -> 오브젝트는? 조상클래스 -> 근데 버그가 많이남 -> 제네릭 <>을 사용하면 됨

Map은 key - value로 되어있음
key는 중복이 안되는 데이터로 해야 함(같으면 나중에 들어온게 덮어써버림)
그래서 set으로 하면 중복이 안되서 같이 씀?

Java의 컬렉션		L				S				M
				List				Set				Map
			ArrayList, LinkedList	HashSet, TreeSet		HashMap, TreeMap
			순차적이다(중복허용)	순차적이지않다(중복X)		순차적이지 않다(key만 중복X),key와value의 페어형태


ArrayList와 LinkedList의 차이

어레이리스트는 배열을 이용함(모든 데이터 상수 시간 접근)
링크드리스트는 노드를 연결함(위치에 따라 이동시간 발생)

어레이리스트는 중간에 배열을 삭제하거나 공간이 부족하면 앞으로 땡기거나 새로만들고 복사해야함
배열이 짧으면 문제 없겠지만 크면 성능저하

링크드리스트는 중간이 삭제되어도 연결부만 수정하면 땡길필요 없음

정리하면 AL은 그냥쓰면 더 빠르지만 수정할 일이 많으면 LL이 더 나음(편리함)

실기) 로또만들기
핵심은 랜덤, 중복방지 -> SET

Tree알고리즘 = 숫자를 딱 넣으면 값이 정해놧던 숫자보다 큰지작은지 비교, 다음 숫자로 이동해서 또 비교
ex) 7을 넣었는데 첫숫자가 5다. 그럼 5보다 큰것 모음으로 감 -> 그다음숫자가 8이다. 그럼 5초과8미만 모음으로 감 이런느낌으로 정렬에 특화되어 있음
TreeSet TreeMap TreeHash가 있음

인스턴스는 왠만하면 private 쓰는게 좋음

비교할때 나오는거
같으면 0, 크면 1, 작으면 -1

iterator 반복자


다시 듣고 싶은 자바 개념)
1. 체크리스트
2. 향상된 for문
3. 예외처리


1.체크리스트

1)자료형 - 자료형(Data Type)은 기본타입(pri?)과 참조타입(referance)이 있음.

2)변수 - 변수(variable)는 변수선언과 인스턴스 or 클래스 변수가 있다. 선언위치에 따라 전역변수,지역변수가 된다. 
인스턴스변수는 new, 클래스변수는 static을 붙임. final을 붙이면 불변(상수)
지역변수는 메소드 끝날때 삭제되고 클래스변수는 안쓰일때 가비지로 들어감. 매개변수는 메소드 안에 전달해주는 값.
선언방법 : dataType 변수명 = 값;

3)메소드 - 기능,처리,동작 즉 액션이다. 구조는 returnType 메소드명 (매개변수) {코드}이다. 매개변수는 입력값. rT는 출력값이다.
호출 방법은 class A의 a메소드일때 newA().a();이다. void는 리턴할게 없다는 뜻이고, 리턴할게 있으면 void대신 데이터타입으로 바꾼다.

4)클래스 - 클래스의 구성요소 3가지 (인스턴스변수 생성자 메소드) 인스턴스변수를 new하면 힙메모리로 올라감. 생성자는 new할때만 실행됨. 메소드는 코딩위치
호출법은 new 클래스명.변수혹은메소드로 부르면댐

5)오버로딩 - 과적재. 생성자오버로딩과 메소드오버로딩이 있다. 동일한 생성자,메소드명을 만들고 매개변수의 개수, 타입, 순서가 다르면 가능하다.

6)new - 객체(클래스)를 생성한다. 생성된 객체는 인스턴스가 되어 메모리에 올라간다(그래야 사용가능). 

7)static - 정적이다(반대는 dynamic). 클래스 로더의 역할을 한다. 스태틱이 붙은걸 모두 메모리에 올린다 이걸 쓰면 new 안써도 됨. 인스턴스변수들이 공유하는 메타적 정보를 올려놓는다.
static 메소드도 공유된 메소드로 쓸 수 있다(공통처리).

8)if for 넘어감


2. 향상된 for문
int[] arr = {1,2,3,4,5};
 for(int a : arr){}


3. 예외처리

비정상적 동작을 감지하면 예방하고 코드가 나가지 않도록 하는 일
try{ }catch(코딩){}로 할 수 있다
중요한건 runtime익셉션(실행중 에러)이 중요함nullPointExceptiom, classCastException, IndexOutOf어쩌구등이 유명함
finally는 에러가 터질때 죽기전에 죽음의 메아리를 발동한다
catch를 안하면 throw를 쓸수도 있음(둘다 쓰려면 catch안에 new throw할 수도 있다)

즉 예외처리는 예방을 하는것이다. catch 하거나 throw로. cathc하고 new 쓰로우도 가능)