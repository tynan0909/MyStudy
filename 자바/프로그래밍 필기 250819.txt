4장 연산자(operator)

+	 -	 *(곱하기)	 	/(몫)		%(나머지)
+=	)
-=	)	더해서 저장해라를 축약한 것
*=	)

== 동등				=== 동등(타입까지)
!= 동등하지 않다			!부정

= 할당


논리

&&	AND 둘다 참여
||	OR 하나만 참여
!	NOT

<< 비트연산(통신쪽에서 씀)

(	)	우선 연산자(괄호안을 먼저 계산)


관계 연산(비교)

a<b		>		<=		>=		==		!=
a가 b보다~							동등		동등하지 않음	


단항 연산

System.out.println(++num); 하면 1추가
System.out.println((num++) + " "); 하면 동작이 끝나고 1추가


5장 if else

if(명제){ } 	명제가 참일 때 만 { } 내부 코드가 실행 됨
else{ } 	대신 else옆에 { } 내부 코드가 실행 됨

if(명제)
	코드		만약 내부 코드가 하나면 { } 생략 가능(회사마다 생략안하는 경우가 있음)
else if(다른명제)
	코드
if(또다른명제)
	코드
			조건에 계속 맞지 않는 경우 계속 내려갈 수 있음

big = (num1 > num2) ? num1 : num2;		if문을 줄일 수 있음(커다란 숫자 표시 가능)

switch는 case랑 섞어서 쓸 수 있음(114페이지)
switch에 break; 넣으면 블럭을 탈출함(코드 종료)

while(num < 5) {						( )내부가 true면 { }내부 코드를 계속 실행함 false면 종료
		System.out.println("I like Java" + num);
		num++;						이 코드는 num이 0~4일때 실행되고 5되면 종료
}									만약 while조건을 true로 하면 계속 오르다가 꽉차면 -가 붙고 거기서부터 올라옴

do {				이 코드는 일단 do옆 { }를 실행하고, 명제가 true일때 다시 반복
	코드;
	num++;
}while(명제)

      초기식  조건식 증강식
for(int i = 0; i < 5; i++)


break & continue

while(명제)	{
	if(명제)
	break;		여기서 break는 조건을 if명제가 true일때 반복을 탈출 함
		}
	num++;

Hash 알고리즘(이정도 짜면 일본에서 적응가능?)

n % 숫자 == 0 	이면 숫자의 배수일때 조건 만족(%는 n을 숫자로 나누고 나머지를 표시하니까)
			그러면 숫자가 소수일 때 보안이 매우 강해짐

continue	이건 아래의 코드를 스킵하고 while을 재실행

while(true)는 무한반복하기에 break가 필수


반복문의 중첩

보통 2중 중첩까지만 쓰고(구구단 만들 때 씀) 그 이상은 버그때문에 잘 안씀

만약 반복문 중첩에서 break를 쓰면 조심해야 함
가장 가까운 반복문만 탈출하고 중첩 전체에서 나가진 못함
전체를 나가고 싶으면 라벨을 사용해서 나갈 위치를 알려주면 됨


실습)	권장레벨:구구단		System.out.println ~~ 에서 ln을 지우면 가로로 찍힘
	별표찍기
	왼쪽삼각형
	가운데 삼각형
	다이아몬드
